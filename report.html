
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>service: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ViniciusMartinsS/manager/internal/application/service/auth.go (100.0%)</option>
				
				<option value="file1">github.com/ViniciusMartinsS/manager/internal/application/service/encryption.go (0.0%)</option>
				
				<option value="file2">github.com/ViniciusMartinsS/manager/internal/application/service/notification.go (0.0%)</option>
				
				<option value="file3">github.com/ViniciusMartinsS/manager/internal/application/service/task.go (0.0%)</option>
				
				<option value="file4">github.com/ViniciusMartinsS/manager/internal/common/date.go (0.0%)</option>
				
				<option value="file5">github.com/ViniciusMartinsS/manager/internal/common/role.go (0.0%)</option>
				
				<option value="file6">github.com/ViniciusMartinsS/manager/internal/controller/common/jwt.go (55.6%)</option>
				
				<option value="file7">github.com/ViniciusMartinsS/manager/internal/controller/common/validation.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package service

import (
        constant "github.com/ViniciusMartinsS/manager/internal/common"
        "github.com/ViniciusMartinsS/manager/internal/controller/common"
        "github.com/ViniciusMartinsS/manager/internal/domain/contract"
        "github.com/ViniciusMartinsS/manager/internal/domain/model"
        "golang.org/x/crypto/bcrypt"
)

type authService struct {
        userRepository contract.UserRepository
}

func NewAuthService(userRepository contract.UserRepository) contract.AuthService <span class="cov8" title="1">{
        return authService{userRepository}
}</span>

func (a authService) Login(email, password string) model.LoginResponse <span class="cov8" title="1">{
        user, err := a.userRepository.FindByEmail(email)

        if err != nil &amp;&amp; constant.DB_ERROR_NOT_AUTHORIZED == err.Error() </span><span class="cov8" title="1">{
                return model.LoginResponse{
                        Code:    constant.NOT_AUTHORIZED_ERROR_CODE,
                        Message: constant.NOT_AUTHORIZED_ERROR_MESSAGE,
                }
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return model.LoginResponse{
                        Code:    constant.INTERNAL_SERVER_ERROR_CODE,
                        Message: constant.INTERNAL_SERVER_ERROR_MESSAGE,
                }
        }</span>

        <span class="cov8" title="1">err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
        if err != nil </span><span class="cov8" title="1">{
                return model.LoginResponse{
                        Code:    constant.NOT_AUTHORIZED_ERROR_CODE,
                        Message: constant.NOT_AUTHORIZED_ERROR_MESSAGE,
                }
        }</span>

        <span class="cov8" title="1">accessToken := common.GenerateAccessToken(int(user.ID), email)
        return model.LoginResponse{Code: 0, AccessToken: accessToken}</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package service

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/hex"
        "fmt"
        "io"

        "github.com/ViniciusMartinsS/manager/internal/domain/contract"
)

type encryptionService struct {
        keyString string
}

func NewEncryptionService(keyString string) contract.EncryptionService <span class="cov0" title="0">{
        return encryptionService{keyString}
}</span>

func (e encryptionService) Encrypt(content string) string <span class="cov0" title="0">{
        key, _ := hex.DecodeString(e.keyString)
        plaintext := []byte(content)

        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">aesGCM, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">nonce := make([]byte, aesGCM.NonceSize())
        if _, err = io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)
        return fmt.Sprintf("%x", ciphertext)</span>
}

func (e encryptionService) Decrypt(contentEncrypted string) string <span class="cov0" title="0">{
        if contentEncrypted == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">key, _ := hex.DecodeString(e.keyString)
        enc, _ := hex.DecodeString(contentEncrypted)

        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">aesGCM, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">nonceSize := aesGCM.NonceSize()
        nonce, ciphertext := enc[:nonceSize], enc[nonceSize:]

        plaintext, err := aesGCM.Open(nil, nonce, ciphertext, nil)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">return fmt.Sprintf("%s", plaintext)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package service

import (
        "fmt"
        "log"

        "github.com/ViniciusMartinsS/manager/internal/common"
        "github.com/ViniciusMartinsS/manager/internal/domain/contract"
        "github.com/ViniciusMartinsS/manager/internal/domain/model"
)

type notificationService struct {
        userRepository contract.UserRepository
}

func NewNotificationService(userRepository contract.UserRepository) contract.NotificationService <span class="cov0" title="0">{
        return notificationService{userRepository}
}</span>

func (n notificationService) Notify(task model.Task) <span class="cov0" title="0">{
        row, err := n.userRepository.FindBydId(task.UserId)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("[ERROR] Gathering user to notify")
                return
        }</span>

        <span class="cov0" title="0">date := common.DateToStr(task.Performed)
        fmt.Printf("\n[NOTIFICATION] The tech %s performed the task %s on date %s\n", row.Name, task.Name, date)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package service

import (
        "fmt"

        constant "github.com/ViniciusMartinsS/manager/internal/common"
        "github.com/ViniciusMartinsS/manager/internal/domain/contract"
        "github.com/ViniciusMartinsS/manager/internal/domain/model"
)

type taskService struct {
        taskRepository      contract.TaskRepository
        userRepository      contract.UserRepository
        notificationService contract.NotificationService
        encryption          contract.EncryptionService
}

func NewTaskService(
        taskRepository contract.TaskRepository,
        userRepository contract.UserRepository,
        notificationService contract.NotificationService,
        encryption contract.EncryptionService,
) contract.TaskService <span class="cov0" title="0">{
        return taskService{taskRepository, userRepository, notificationService, encryption}
}</span>

func (t taskService) List(userId int) model.TaskResponse <span class="cov0" title="0">{
        var rows []model.Task

        user, err := t.userRepository.FindBydId(userId)
        if err != nil </span><span class="cov0" title="0">{
                return model.TaskResponse{
                        Code:    constant.INTERNAL_SERVER_ERROR_CODE,
                        Message: constant.INTERNAL_SERVER_ERROR_MESSAGE,
                }
        }</span>

        <span class="cov0" title="0">if constant.IsManager(user.Role.Name) </span><span class="cov0" title="0">{
                rows, err = t.taskRepository.FindAll()
        }</span>

        <span class="cov0" title="0">if constant.IsTechnician(user.Role.Name) </span><span class="cov0" title="0">{
                rows, err = t.taskRepository.FindByUserId(userId)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return model.TaskResponse{
                        Code:    constant.INTERNAL_SERVER_ERROR_CODE,
                        Message: constant.INTERNAL_SERVER_ERROR_MESSAGE,
                }
        }</span>

        <span class="cov0" title="0">result := make([]model.TaskResponseContent, len(rows))

        if len(rows) == 0 </span><span class="cov0" title="0">{
                return model.TaskResponse{Code: constant.SUCCESS_CODE, Result: result}
        }</span>

        <span class="cov0" title="0">for i, r := range rows </span><span class="cov0" title="0">{
                result[i] = t.formatResponse(r)
        }</span>

        <span class="cov0" title="0">return model.TaskResponse{Code: constant.SUCCESS_CODE, Result: result}</span>
}

func (t taskService) Create(userId int, payload model.TaskPayload) model.TaskResponse <span class="cov0" title="0">{
        task := model.Task{
                Name:      payload.Name,
                Summary:   t.encryption.Encrypt(payload.Summary),
                Performed: constant.StrToDate(payload.Performed),
                UserId:    userId,
        }

        if task.Performed != nil </span><span class="cov0" title="0">{
                t.notificationService.Notify(task) // go
        }</span>

        <span class="cov0" title="0">row, err := t.taskRepository.Create(task)
        if err != nil </span><span class="cov0" title="0">{
                return model.TaskResponse{
                        Code:    constant.INTERNAL_SERVER_ERROR_CODE,
                        Message: constant.INTERNAL_SERVER_ERROR_MESSAGE,
                }
        }</span>

        <span class="cov0" title="0">result := make([]model.TaskResponseContent, 0)
        result = append(result, t.formatResponse(row))

        return model.TaskResponse{Code: constant.SUCCESS_CODE, Result: result}</span>
}

func (t taskService) Update(id int, userId int, payload model.TaskPayload) model.TaskResponse <span class="cov0" title="0">{
        task := model.Task{
                Name:      payload.Name,
                Summary:   payload.Summary,
                Performed: constant.StrToDate(payload.Performed),
                UserId:    userId,
        }

        if task.Summary != "" </span><span class="cov0" title="0">{
                task.Summary = t.encryption.Encrypt(payload.Summary)
        }</span>

        <span class="cov0" title="0">if task.Performed != nil </span><span class="cov0" title="0">{
                t.notificationService.Notify(task) // go
        }</span>

        <span class="cov0" title="0">row, err := t.taskRepository.Update(id, userId, task)

        if err != nil </span><span class="cov0" title="0">{
                return model.TaskResponse{
                        Code:    constant.INTERNAL_SERVER_ERROR_CODE,
                        Message: constant.INTERNAL_SERVER_ERROR_MESSAGE,
                }
        }</span>

        <span class="cov0" title="0">result := make([]model.TaskResponseContent, 0)
        result = append(result, t.formatResponse(row))

        return model.TaskResponse{Code: constant.SUCCESS_CODE, Result: result}</span>
}

func (t taskService) Delete(id int, userId int) model.TaskResponse <span class="cov0" title="0">{
        user, err := t.userRepository.FindBydId(userId)
        if err != nil </span><span class="cov0" title="0">{
                return model.TaskResponse{
                        Code:    constant.INTERNAL_SERVER_ERROR_CODE,
                        Message: constant.INTERNAL_SERVER_ERROR_MESSAGE,
                }
        }</span>

        <span class="cov0" title="0">if constant.IsTechnician(user.Role.Name) </span><span class="cov0" title="0">{
                return model.TaskResponse{
                        Code:    constant.FORBIDDEN_ERROR_CODE,
                        Message: constant.FORBIDDEN_ERROR_MESSAGE,
                }
        }</span>

        <span class="cov0" title="0">_, err = t.taskRepository.Delete(id)
        if err != nil </span><span class="cov0" title="0">{
                return model.TaskResponse{
                        Code:    constant.INTERNAL_SERVER_ERROR_CODE,
                        Message: constant.INTERNAL_SERVER_ERROR_MESSAGE,
                }
        }</span>

        <span class="cov0" title="0">message := fmt.Sprintf(constant.SUCCESS_DELETE_MESSAGE, id)
        return model.TaskResponse{Code: constant.SUCCESS_CODE, Message: message}</span>
}

func (t taskService) formatResponse(response model.Task) model.TaskResponseContent <span class="cov0" title="0">{
        return model.TaskResponseContent{
                ID:        int(response.ID),
                Name:      response.Name,
                Summary:   t.encryption.Decrypt(response.Summary),
                Performed: constant.DateToStr(response.Performed),
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package common

import "time"

func StrToDate(value string) *time.Time <span class="cov0" title="0">{
        if value == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">date, err := time.Parse(DATE_FORMAT, value)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return &amp;date</span>
}

func DateToStr(value *time.Time) string <span class="cov0" title="0">{
        if value == nil </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return value.Format(DATE_FORMAT)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package common

const MANAGER = "Manager"
const TECHNICIAN = "Technician"

func IsManager(role string) bool <span class="cov0" title="0">{
        return role == MANAGER
}</span>

func IsTechnician(role string) bool <span class="cov0" title="0">{
        return role == TECHNICIAN
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package common

import (
        "time"

        "github.com/ViniciusMartinsS/manager/internal/domain/model"
        "github.com/golang-jwt/jwt"
)

var jwtKey = []byte("my_secret_key")

var key = func(token *jwt.Token) (interface{}, error) <span class="cov0" title="0">{
        return jwtKey, nil
}</span>

func IsAccessTokenValid(accessToken string) (bool, *model.Claims) <span class="cov0" title="0">{
        claims := &amp;model.Claims{}
        token, _ := jwt.ParseWithClaims(accessToken, claims, key)
        return token.Valid, claims
}</span>

func GenerateAccessToken(id int, email string) string <span class="cov8" title="1">{
        expirationTime := time.Now().Add(150 * time.Minute)

        claims := &amp;model.Claims{
                Email:  email,
                UserId: id,
                StandardClaims: jwt.StandardClaims{
                        ExpiresAt: expirationTime.Unix(),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        accessToken, _ := token.SignedString(jwtKey)

        return accessToken
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package common

import (
        "encoding/json"
        "fmt"
        "regexp"

        constant "github.com/ViniciusMartinsS/manager/internal/common"
        "github.com/ViniciusMartinsS/manager/internal/domain/model"
        "github.com/go-playground/validator/v10"
)

type TaskCreateDTO struct {
        Name      string  `validate:"required"`
        Summary   string  `validate:"required,max=2500"`
        Performed *string `json:",omitempty"`
}

type TaskUpdateDTO struct {
        Name      string  `json:",omitempty"`
        Summary   string  `json:",omitempty" validate:"max=2500"`
        Performed *string `json:",omitempty"`
}

var validate *validator.Validate

func ValidateLoginSchema(body []byte) error <span class="cov0" title="0">{
        var login model.LoginPayload

        err := json.Unmarshal(body, &amp;login)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">validate = validator.New()

        err = validate.Struct(login)
        if err == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return err</span>
}

func ValidateTaskCreateSchema(body []byte) error <span class="cov0" title="0">{
        var task TaskCreateDTO
        err := json.Unmarshal(body, &amp;task)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">validate = validator.New()

        err = validate.Struct(task)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = ValidateDateFormat(task.Performed)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func ValidateTaskUpdateSchema(body []byte) error <span class="cov0" title="0">{
        var task TaskUpdateDTO
        err := json.Unmarshal(body, &amp;task)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">validate = validator.New()

        err = validate.Struct(task)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = ValidateDateFormat(task.Performed)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func ValidateDateFormat(performed *string) error <span class="cov0" title="0">{
        if performed == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">matched, _ := regexp.MatchString(constant.DATE_REGEX, *performed)
        if matched </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">err := fmt.Errorf(constant.DATE_BAD_REQUEST)
        return err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
